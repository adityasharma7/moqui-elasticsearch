<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domain Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-2.0.xsd">

    <service verb="index" noun="DataDocuments" authenticate="false">
        <description>Indexes documents passed using ElasticSearch. The DataDocument must have an indexName.</description>
        <implements service="org.moqui.EntityServices.receive#DataFeed"/>
        <in-parameters>
            <parameter name="dataFeedId" required="false"/>
            <parameter name="feedStamp" type="Timestamp" required="false"/>
            <parameter name="getOriginalDocuments" type="Boolean" default="false"/>
        </in-parameters>
        <out-parameters>
            <parameter name="documentVersionList" type="List" required="true"/>
            <parameter name="originalDocumentList" type="List" required="false"/>
        </out-parameters>
        <actions>
            <script>
                import org.elasticsearch.client.Client
                import org.elasticsearch.action.get.GetResponse
                import org.elasticsearch.action.index.IndexResponse
                import org.slf4j.Logger
                import org.slf4j.LoggerFactory
                import org.moqui.context.ExecutionContext
                import org.moqui.elasticsearch.ElasticSearchUtil

                ExecutionContext ec = context.ec
                Client elasticSearchClient = ec.getTool("ElasticSearch", Client.class)
                Logger logger = LoggerFactory.getLogger("org.moqui.elasticsearch.SearchServices.indexDataDocuments")

                // Make sure all indices exist
                Set indexNames = new HashSet()
                for (Map document in documentList) indexNames.add(document._index)
                for (String indexName in indexNames) ElasticSearchUtil.checkCreateIndex(indexName, ec)

                documentVersionList = []
                originalDocumentList = getOriginalDocuments ? [] : null
                for (Map document in documentList) {
                    // logger.warn("====== Indexing document: ${document}")

                    String _index = document._index
                    String _type = document._type
                    String _id = document._id
                    String _timestamp = document._timestamp
                    // As of ES 2.0 _index, _type, _id, and _timestamp shouldn't be in document to be indexed
                    document.remove('_index'); document.remove('_type'); document.remove('_id');
                    document.remove('_timestamp');

                    if (getOriginalDocuments) {
                        // this may fail for a number of reasons, like index doesn't exist yet, so catch the exception
                        try {
                            GetResponse gr = elasticSearchClient.prepareGet(_index, _type, _id).execute().actionGet()
                            Map originalDocument = gr.getSourceAsMap()
                            if (originalDocument != null) {
                                // As of ES 2.0 _index, _type, _id aren't included in the document
                                originalDocument._index = gr.getIndex()
                                originalDocument._type = gr.getType()
                                originalDocument._id = gr.getId()
                                // how to get timestamp? doesn't seem to be in API: document._timestamp = hit.get?
                                originalDocument._version = gr.getVersion()
                                originalDocumentList.add(originalDocument ?: [:])
                            } else {
                                originalDocumentList.add([:])
                            }
                        } catch (Exception e) {
                            logger.info("Could not get original document for [${_index}, ${_type}, ${_id}]: ${e.toString()}")
                            originalDocumentList.add([:])
                        }
                    }
                    // Groovy DSL version
                    // IndexResponse response = elasticSearchClient.index { index document._index; type document._type;
                    //     id document._id; source document; }.actionGet()
                    // Java API version
                    IndexResponse response = elasticSearchClient.prepareIndex(_index, _type, _id)
                            .setIndex(_index).setType(_type).setId(_id).setTimestamp(_timestamp)
                            .setSource(document).execute().actionGet()

                    documentVersionList.add(response.getVersion())
                    if (logger.isTraceEnabled()) logger.trace("Indexed [${_index}, ${_type}, ${_id}] version [${response.getVersion()}]")
                    // logger.warn("====== Indexed [${_index}, ${_type}, ${_id}] version [${response.getVersion()}] created? ${response.isCreated()}}")
                }
            </script>
        </actions>
    </service>
    <service verb="put" noun="DataDocumentMappings">
        <in-parameters><parameter name="indexName" required="true"/></in-parameters>
        <actions><script>org.moqui.elasticsearch.ElasticSearchUtil.putIndexMappings(indexName, ec)</script></actions>
    </service>

    <service verb="index" noun="DataFeedDocuments" authenticate="false" transaction-timeout="600">
        <description>Index all documents associated with the feed within the date range. Recommend calling through the IndexDataFeedDocuments service job.</description>
        <in-parameters>
            <parameter name="dataFeedId" required="true"/>
            <parameter name="fromUpdateStamp" type="Timestamp"/>
            <parameter name="thruUpdateStamp" type="Timestamp"/>
        </in-parameters>
        <out-parameters>
            <parameter name="documentsIndexed" type="Integer"/>
        </out-parameters>
        <actions>
            <set field="documentList" from="ec.entity.getEntityDataFeed().getFeedDocuments(dataFeedId, fromUpdateStamp, thruUpdatedStamp)"/>
            <set field="feedStamp" from="thruUpdateStamp ?: ec.user.nowTimestamp"/>
            <if condition="documentList">
                <service-call name="org.moqui.elasticsearch.SearchServices.index#DataDocuments" in-map="context"/>
            </if>
            <set field="documentsIndexed" from="documentList?.size() ?: 0"/>
            <message>Indexed ${documentsIndexed} documents</message>
        </actions>
    </service>

    <service verb="index" noun="WikiSpacePages">
        <description>Find all pages in space, make sure each has a WikiPage record, and index the page for searching.</description>
        <in-parameters>
            <parameter name="wikiSpaceId"/>
            <parameter name="dataDocumentId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="org.moqui.impl.WikiServices.get#WikiSpacePages" in-map="[wikiSpaceId:wikiSpaceId]" out-map="context"/>

            <set field="recordsCreated" from="0"/>
            <set field="documentList" from="[]"/>
            <iterate list="allChildFileFlatList" entry="allChildFileFlat">
                <service-call name="org.moqui.impl.WikiServices.get#WikiPageId" out-map="getWpiResult"
                              in-map="[wikiSpaceId:wikiSpaceId, pagePath:allChildFileFlat.path, createIfMissing:true]"/>
                <if condition="getWpiResult.createdRecord"><set field="recordsCreated" from="recordsCreated + 1"/></if>

                <script>documentList.addAll(ec.entity.getDataDocuments(dataDocumentId,
                    ec.entity.conditionFactory.makeCondition([wikiPageId:getWpiResult.wikiPageId]), null, null))</script>
            </iterate>
            <script>ec.service.sync().name("org.moqui.elasticsearch.SearchServices.index#DataDocuments")
                .parameters([documentList:documentList]).call()</script>

            <message>Found and indexed ${allChildFileFlatList.size()} pages in Wiki Space [${wikiSpaceId}], created DB records for ${recordsCreated}.</message>
        </actions>
    </service>

    <service verb="search" noun="DataDocuments">
        <description>
            The queryString format is the ElasticSearch supported one, based on the Lucene query strings which are
            partly documented here:

            http://lucene.apache.org/core/4_9_1/queryparser/org/apache/lucene/queryparser/classic/package-summary.html
            http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html#query-string-syntax

            Sort options are described here:

            http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/search-request-sort.html
        </description>
        <in-parameters>
            <parameter name="indexName" required="true"/>
            <parameter name="documentType"><description>The ElasticSearch document type. For DataDocument based docs
                this is the dataDocumentId.</description></parameter>
            <parameter name="queryString" required="true"/>
            <parameter name="orderByFields" type="List"><parameter name="orderByField"/></parameter>
            <parameter name="pageIndex" type="Integer" default="0"/>
            <parameter name="pageSize" type="Integer" default="20"/>
            <parameter name="flattenDocument" type="Boolean" default="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="documentList" type="List">
                <description>List of documents, each document is a Map with nested Maps and Lists of Maps.</description>
                <parameter name="document" type="Map"/>
            </parameter>
            <parameter name="documentListCount" type="Integer"><description>The total count of hits, not just the
                limited number returned.</description></parameter>
            <parameter name="documentListPageIndex" type="Integer"/>
            <parameter name="documentListPageSize" type="Integer"/>
            <parameter name="documentListPageMaxIndex" type="Integer"/>
            <parameter name="documentListPageRangeLow" type="Integer"/>
            <parameter name="documentListPageRangeHigh" type="Integer"/>
        </out-parameters>
        <actions>
            <set field="fromOffset" from="pageIndex * pageSize"/>
            <set field="sizeLimit" from="pageSize"/>
            <!-- if documentType is an empty String it will find no results! -->
            <set field="documentType" from="documentType ?: null"/>
            <script>
                /* useful docs for query API: http://www.elasticsearch.org/guide/reference/api/search/uri-request/ */

                import org.elasticsearch.client.Client
                import org.elasticsearch.action.get.MultiGetItemResponse
                import org.elasticsearch.action.get.MultiGetRequestBuilder
                import org.elasticsearch.action.search.SearchRequestBuilder
                import org.elasticsearch.index.query.QueryBuilders
                import org.elasticsearch.search.SearchHit
                import org.elasticsearch.search.SearchHits
                import org.elasticsearch.search.sort.SortOrder
                import org.moqui.context.ExecutionContext
                import org.moqui.elasticsearch.ElasticSearchUtil

                ExecutionContext ec = context.ec
                Client elasticSearchClient = ec.getTool("ElasticSearch", Client.class)

                documentList = []

                if (!indexName.contains("__")) indexName = "${ec.tenantId}__${indexName}".toLowerCase()

                // make sure index exists
                ElasticSearchUtil.checkCreateIndex(indexName, ec)

                // get the search hits
                SearchRequestBuilder srb = elasticSearchClient.prepareSearch().setIndices(indexName).setTypes(documentType)
                        .setQuery(QueryBuilders.queryStringQuery(queryString)).setFrom(fromOffset).setSize(sizeLimit)
                        .setFetchSource(true)
                for (String orderByField in orderByFields) {
                    boolean ascending = true
                    if (orderByField.charAt(0) == '-') {
                        ascending = false
                        orderByField = orderByField.substring(1)
                    } else if (orderByField.charAt(0) == '+') {
                        ascending = true
                        orderByField = orderByField.substring(1)
                    }
                    // ec.logger.warn("========= adding ${orderByField}, ${ascending}")
                    srb.addSort(orderByField, ascending ? SortOrder.ASC : SortOrder.DESC)
                }

                SearchHits hits = srb.execute().actionGet().getHits()
                for (SearchHit hit in hits) {
                    Map document = hit.getSource()
                    // As of ES 2.0 _index, _type, _id aren't included in the document
                    document._index = hit.getIndex()
                    document._type = hit.getType()
                    document._id = hit.getId()
                    // how to get timestamp? doesn't seem to be in API: document._timestamp = hit.get?
                    document._version = hit.getVersion()
                    documentList.add(flattenDocument ? StupidUtilities.flattenNestedMap(document) : document)
                }

                /* the old approach, without .setFetchSource(true)
                if (hits.getTotalHits() > 0) {
                    MultiGetRequestBuilder mgrb = elasticSearchClient.prepareMultiGet()
                    for (SearchHit hit in hits) mgrb.add(hit.getIndex(), hit.getType(), hit.getId())
                    Iterator mgirIt = mgrb.execute().actionGet().iterator()
                    while(mgirIt.hasNext()) {
                        MultiGetItemResponse mgir = mgirIt.next()
                        Map document = mgir.getResponse().getSourceAsMap()
                        documentList.add(flattenDocument ? StupidUtilities.flattenNestedMap(document) : document)
                    }
                }
                 */

                // get the total search count
                // TODO: replace deprecated (in 2.1.0) prepareCount(), release notes say: "Deprecate the count api in favour of search with size 0"
                documentListCount = elasticSearchClient.prepareCount(indexName).setTypes(documentType)
                        .setQuery(QueryBuilders.queryStringQuery(queryString)).execute().actionGet().getCount()
                // this doesn't work: documentListCount = srb.execute().actionGet().getCount()

                // calculate the pagination values
                documentListPageIndex = pageIndex
                documentListPageSize = pageSize
                documentListPageMaxIndex = ((BigDecimal) documentListCount - 1).divide(documentListPageSize, 0, BigDecimal.ROUND_DOWN) as int
                documentListPageRangeLow = documentListPageIndex * documentListPageSize + 1
                documentListPageRangeHigh = (documentListPageIndex * documentListPageSize) + documentListPageSize
                if (documentListPageRangeHigh > documentListCount) documentListPageRangeHigh = documentListCount
            </script>
        </actions>
    </service>

    <service verb="search" noun="CountBySource">
        <description>
            Search documents with a "count" type search, meant for analytics searches with aggregations.
            Use either the sourceJson or sourceMap parameters for the search source.

            A good overview of the use of aggregations is available at: http://www.elastic.co/guide/en/elasticsearch/guide/current/aggregations.html

            For detailed documentation of aggregations including all aggregation types see: http://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html
        </description>
        <in-parameters>
            <parameter name="indexName" required="true"/>
            <parameter name="documentTypeList" type="List">
                <description>The ElasticSearch document type. For DataDocument based docs this is the dataDocumentId.</description>
                <parameter name="documentType"/>
            </parameter>
            <parameter name="maxResults" type="Integer" default="1000"/>
            <parameter name="sourceJson"/>
            <parameter name="sourceMap" type="Map"/>
        </in-parameters>
        <out-parameters>
            <parameter name="searchResponse" type="org.elasticsearch.action.search.SearchResponse"/>
            <!-- Get this with "searchResponse.toString()" if needed: <parameter name="responseString"/> -->
        </out-parameters>
        <actions>
            <script>
                import org.elasticsearch.client.Client
                import org.elasticsearch.action.search.SearchRequestBuilder
                import org.elasticsearch.action.search.SearchResponse
                import org.moqui.context.ExecutionContext
                import org.moqui.elasticsearch.ElasticSearchUtil

                ExecutionContext ec = context.ec
                Client elasticSearchClient = ec.getTool("ElasticSearch", Client.class)

                if (!indexName.contains('__')) indexName = "${ec.tenantId}__${indexName}".toLowerCase()

                // make sure index exists
                ElasticSearchUtil.checkCreateIndex(indexName, ec)

                // get the search hits
                SearchRequestBuilder srb = elasticSearchClient.prepareSearch().setIndices((String) indexName)
                        .setSearchType('count').setSize(maxResults)
                if (documentTypeList) srb.setTypes((String[]) documentTypeList.toArray(new String[documentTypeList.size()]))
                if (sourceJson) srb.setExtraSource((String) sourceJson)
                if (sourceMap) srb.setExtraSource((Map) sourceMap)

                searchResponse = srb.execute().actionGet()
                // aggregations = searchResponse.getAggregations().getAsMap()
                // responseString = searchResponse.toString()
            </script>
        </actions>
    </service>
</services>
